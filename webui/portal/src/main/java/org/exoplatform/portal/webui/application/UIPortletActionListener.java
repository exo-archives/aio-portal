/***************************************************************************
 * Copyright 2001-2003 The eXo Platform SARL         All rights reserved.  *
 * Please look at license.txt in info directory for more license detail.   *
 **************************************************************************/
package org.exoplatform.portal.webui.application;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.portlet.PortletMode;
import javax.portlet.WindowState;
import javax.xml.namespace.QName;

import org.apache.commons.logging.Log;
import org.exoplatform.container.ExoContainer;
import org.exoplatform.portal.application.PortalRequestContext;
import org.exoplatform.portal.webui.page.UIPage;
import org.exoplatform.portal.webui.page.UIPageBody;
import org.exoplatform.portal.webui.portal.UIPortal;
import org.exoplatform.portal.webui.util.Util;
import org.exoplatform.portal.webui.workspace.UIMaskWorkspace;
import org.exoplatform.portal.webui.workspace.UIPortalApplication;
import org.exoplatform.portal.webui.workspace.UIWorkspace;
import org.exoplatform.services.log.ExoLogger;
import org.exoplatform.services.organization.OrganizationService;
import org.exoplatform.services.organization.UserProfile;
import org.exoplatform.services.portletcontainer.PortletContainerService;
import org.exoplatform.services.portletcontainer.pci.ActionInput;
import org.exoplatform.services.portletcontainer.pci.ActionOutput;
import org.exoplatform.webui.core.UIComponent;
import org.exoplatform.webui.event.Event;
import org.exoplatform.webui.event.EventListener;
import org.exoplatform.webui.event.Event.Phase;

/**
 * May 29, 2006
 */
public class UIPortletActionListener   {
  
  public static final String PORTLET_EVENTS = "PortletEvents";
  
  protected static Log log = ExoLogger.getLogger("portal:UIPortletActionListener");
  
  /**
   * The process action listener is called when an ActionURL generated by the 
   * portlet container has been invoked by the client
   * 
   *  The call is delegated to the portlet container iteself using the method
   *  portletContainer.processAction(...). It returns an object of type ActionOutput that
   *  contains several information such as the next window state and portlet modes (if they
   *  have to change) as well as a list of Events to be broadcasted to the other portlets 
   *  located in the same portal page
   */
  static public class ProcessActionActionListener  extends EventListener<UIPortlet> {
    public void execute(Event<UIPortlet> event) throws Exception {
      UIPortlet uiPortlet = event.getSource() ;
      PortalRequestContext prcontext = (PortalRequestContext) event.getRequestContext();
      ExoContainer container = 
        event.getRequestContext().getApplication().getApplicationServiceContainer() ;
      UIPortalApplication uiPortalApp = uiPortlet.getAncestorOfType(UIPortalApplication.class);
      PortletContainerService portletContainer = 
        (PortletContainerService) container.getComponentInstanceOfType(PortletContainerService.class);
      ActionInput actionInput = new ActionInput();
      OrganizationService service = uiPortlet.getApplicationComponent(OrganizationService.class);
      UserProfile userProfile = service.getUserProfileHandler().findUserProfileByName(uiPortalApp.getOwner()) ;
      actionInput.setWindowID(uiPortlet.getExoWindowID());
      if(userProfile != null) actionInput.setUserAttributes(userProfile.getUserInfoMap());
      else actionInput.setUserAttributes(new HashMap());
      actionInput.setPortletMode(uiPortlet.getCurrentPortletMode());
      actionInput.setWindowState(uiPortlet.getCurrentWindowState());
      actionInput.setMarkup("text/html");
      actionInput.setStateChangeAuthorized(true);
      ActionOutput output = 
        portletContainer.processAction(prcontext.getRequest(), prcontext.getResponse(), actionInput);
      
      /*
       * Update the portlet window state according to the action output information
       * 
       *  If the current node is displaying a usual layout page, also tells the page which portlet to
       *  render or not when the state is maximized
       */
      WindowState state = output.getNextState() ;
      if (state != null ) {
        UIPage uiPage =  uiPortlet.getAncestorOfType(UIPage.class) ;
        if (state == WindowState.MAXIMIZED) {
          uiPortlet.setCurrentWindowState(WindowState.MAXIMIZED) ;
          if (uiPage != null) uiPage.setMaximizedUIPortlet(uiPortlet) ;
        } else if (state == WindowState.MINIMIZED ) {
          uiPortlet.setCurrentWindowState(WindowState.MINIMIZED) ;
          if(uiPage != null) uiPage.setMaximizedUIPortlet(null) ;
        } else {
          uiPortlet.setCurrentWindowState(WindowState.NORMAL) ;
          if(uiPage != null) uiPage.setMaximizedUIPortlet(null) ;
        }
      }  
       
      // update the portlet with the next mode to display
      PortletMode portletMode = output.getNextMode();
      if(portletMode != null) {
        if(portletMode.equals(PortletMode.HELP.toString())) {
          uiPortlet.setCurrentPortletMode(PortletMode.HELP) ;     
        }else if(portletMode.equals(PortletMode.EDIT.toString())){ 
          uiPortlet.setCurrentPortletMode(PortletMode.EDIT) ;
        } else {
          uiPortlet.setCurrentPortletMode(PortletMode.VIEW) ;
        }
      }

      /*
       * Cache the render parameters in the UI portlet component to handle the navigational 
       * state. Each time a portlet is rendered (except using directly a RenderURL) those
       * parameters are added to the portlet request to preserve the portlet state among 
       * all the portal clicks
       */ 
      uiPortlet.setRenderParametersMap(output.getRenderParameters()) ;
      
      /*
       * Handle the events returned by the action output and broadcast a new UI event to
       * the ProcessEventsActionListener that will then target the portlet container 
       * service dircetly
       */
       Map events = output.getEvents();
       if(events != null) {
    	 prcontext.setAttribute(PORTLET_EVENTS, new EventsWrapper(events));
    	 uiPortlet.createEvent("ProcessEvents", Phase.PROCESS, prcontext).broadcast();
       }
    }
  }
  
  /**
   * Process Events sent by the portlet API during the processAction() and serverResource() 
   * methods defined in Portlet API 2.0 (JSR 286)
   */
  static public class ProcessEventsActionListener  extends EventListener<UIPortlet> {
	public void execute(Event<UIPortlet> event) throws Exception {      
      UIPortlet uiPortlet = event.getSource() ;
      PortalRequestContext context = (PortalRequestContext) event.getRequestContext();
      List<UIPortlet> porletInstancesInPage = new ArrayList<UIPortlet>();
      UIPortal uiPortal = uiPortlet.getAncestorOfType(UIPortal.class);
      uiPortal.findComponentOfType(porletInstancesInPage, UIPortlet.class);
      EventsWrapper eventsWrapper = (EventsWrapper) event.getRequestContext().getAttribute(PORTLET_EVENTS);
      Map events = eventsWrapper.getEvents();
      Set eventNames = events.keySet();
      /*
       * Iterate over all the events that the processAction or serverResource have generated.
       * Chek among all the portlet instances deployed in the page (usual layout or webos) 
       * which instance can be targeted by the event and then process the event on the 
       * associated UIPortlet component
       */
      for (Iterator iter = eventNames.iterator(); iter.hasNext();) {
		QName eventName = (QName) iter.next();
		for (Iterator iterator = porletInstancesInPage.iterator(); iterator.hasNext();) {
		  UIPortlet uiPortletInPage = (UIPortlet) iterator.next();
		  if(uiPortletInPage.supportsProcessingEvent(eventName) && !eventsWrapper.isInvokedTooManyTimes(
			  uiPortletInPage.getWindowId())) {
			Map newEvents = uiPortletInPage.processEvent((javax.portlet.Event)events.get(eventName));
			eventsWrapper.increaseCounter(uiPortletInPage.getWindowId());
			if(context.useAjax()) {
			  log.info("Events where generated inside the scope of an AJAX call, hence will only refresh the targeted portlets");
			  event.getRequestContext().addUIComponentToUpdateByAjax(uiPortletInPage);
			} else {
			  log.info("Events where generated outside the scope of an AJAX call, hence will make a full render of the page");
			  context.setFullRender(true);
			}
			if(newEvents != null && !newEvents.isEmpty()) {
			  log.info("The portlet: " + uiPortletInPage.getWindowId() + " processEvent() method has generated new events itself");
		   	  events.putAll(newEvents);
		   	  uiPortlet.createEvent("ProcessEvents", Phase.PROCESS, context).broadcast();
			}			
		  }		  
		}
	  }
    }
  }
	  
  /**
   * This listener is called when a RenderURL url has been generated by the portlet
   * container. In that case it means that the render() method of a targeted portlet
   * will be directly called and that the existing navigational state will be reset
   * by removing all the Render Parameters from the cache map located in the UIPortlet 
   */
  static public class RenderActionListener  extends EventListener<UIPortlet> {
    public void execute(Event<UIPortlet> event) throws Exception {      
      UIPortlet uiPortlet = event.getSource() ;
      uiPortlet.setRenderParametersMap(null) ;
    }
  }
  
  static public class ChangeWindowStateActionListener extends EventListener<UIPortlet> {
    public void execute(Event<UIPortlet> event) throws Exception {      
      UIPortlet uiPortlet = event.getSource();
      
      UIPortalApplication uiPortalApp = uiPortlet.getAncestorOfType(UIPortalApplication.class);
      UIWorkspace uiWorkingWS = uiPortalApp.findComponentById(UIPortalApplication.UI_WORKING_WS_ID);
      PortalRequestContext pcontext = (PortalRequestContext)event.getRequestContext();
      pcontext.addUIComponentToUpdateByAjax(uiWorkingWS);
      pcontext.setFullRender(true);
      
      String windowState = event.getRequestContext().getRequestParameter(UIComponent.OBJECTID).trim();
      UIPageBody uiPageBody = uiPortlet.getAncestorOfType(UIPageBody.class);
      if(windowState.equals(WindowState.MAXIMIZED.toString())){ 
        if(uiPageBody !=  null){
          uiPortlet.setCurrentWindowState(WindowState.MAXIMIZED) ;
          uiPageBody.setMaximizedUIComponent(uiPortlet);
        }else{
          uiPortlet.setCurrentWindowState(WindowState.NORMAL);
        }
        return;
      }
      if(uiPageBody != null){
        UIPortlet maxPortlet = (UIPortlet)uiPageBody.getMaximizedUIComponent(); 
        if(maxPortlet == uiPortlet) uiPageBody.setMaximizedUIComponent(null);
      }
      if(windowState.equals(WindowState.MINIMIZED.toString())) { 
        uiPortlet.setCurrentWindowState(WindowState.MINIMIZED) ;
        return ;
      } 
      uiPortlet.setCurrentWindowState(WindowState.NORMAL);
      
    }
  }
    
  /**
   * This listener is called when the portlet mode of a portlet has to be changed.
   */
  static public class ChangePortletModeActionListener extends EventListener<UIPortlet> {
    public void execute(Event<UIPortlet> event) throws Exception {   
      UIPortlet uiPortlet = event.getSource();
      String portletMode = event.getRequestContext().getRequestParameter(UIComponent.OBJECTID);
      log.info("Change portlet mode of " + uiPortlet.getWindowId() + " to " + portletMode);
      if(portletMode.equals(PortletMode.HELP.toString())) {
        uiPortlet.setCurrentPortletMode(PortletMode.HELP) ;     
      }else if(portletMode.equals(PortletMode.EDIT.toString())){ 
        uiPortlet.setCurrentPortletMode(PortletMode.EDIT) ;
      } else {
        uiPortlet.setCurrentPortletMode(PortletMode.VIEW) ;
      }
      event.getRequestContext().addUIComponentToUpdateByAjax(uiPortlet);
    }
  }
  
  /**
   * This listener is called when the portlet edit form (which tells information about
   * the portlet width or height as well as if the info bar and its content should be
   * shown) is invoked.
   * 
   *  It places the form in the portal black mask
   */
  static public class EditPortletActionListener extends EventListener<UIPortlet> {
    public void execute(Event<UIPortlet> event) throws Exception {  
      UIPortal uiPortal = Util.getUIPortal();
      UIPortalApplication uiApp = uiPortal.getAncestorOfType(UIPortalApplication.class);      
      UIMaskWorkspace uiMaskWS = uiApp.getChildById(UIPortalApplication.UI_MASK_WS_ID) ;       
    
      UIPortlet uiPortlet = event.getSource();
      UIPortletForm uiPortletForm = uiMaskWS.createUIComponent(UIPortletForm.class, null, null); 
      uiPortletForm.setValues(uiPortlet);
      uiMaskWS.setUIComponent(uiPortletForm);
      uiMaskWS.setWindowSize(800, -1);
      uiMaskWS.setShow(true);
      
      //event.getRequestContext().addUIComponentToUpdateByAjax(uiMaskWS);
      Util.updateUIApplication(event);  
      event.getRequestContext().addUIComponentToUpdateByAjax(uiMaskWS);
    }
  }
  
  
}
